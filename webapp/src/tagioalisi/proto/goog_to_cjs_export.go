package main

import (
	"bytes"
	"flag"
	"fmt"
	"io/ioutil"
	"log"
	"os"
	"regexp"
)

var logInfo = log.New(os.Stdout, "goog-to-js: [.] ", 0)
var logError = log.New(os.Stderr, "goog-to-js: [⚠️] ", 0)

// var reExportSymbol = regexp.MustCompile(`goog.exportSymbol\('([^']*)', null, global\);`)
var reExportSymbol = regexp.MustCompile(`goog.exportSymbol\('(.+)', null, global\);`)
var reExtendExports = regexp.MustCompile(`goog.object.extend\(exports, (.+)\);`)

func patchGoogExportsToCjs(file string) bool {
	logInfo.Printf("Processing %s", file)
	contents, err := ioutil.ReadFile(file)
	if err != nil {
		logError.Printf("could not read %s: %v", file, err)
		return false
	}
	lines := bytes.Split(contents, []byte{'\n'})
	editedLines := [][]byte{}

	exportSymbols := [][]byte{}
	extendExports := [][]byte{}

	// Scan the lines for goog exports and for goog extending the "exports" object
	for _, line := range lines {
		commentLine := false
		foundExportSymbol := reExportSymbol.FindSubmatch(line)
		if foundExportSymbol != nil {
			exportSymbols = append(exportSymbols, foundExportSymbol[1])
			logInfo.Printf("  Found symbol: %s", string(foundExportSymbol[1]))
		}

		foundExtendExports := reExtendExports.FindSubmatch(line)
		if foundExtendExports != nil {
			extendExports = append(extendExports, foundExtendExports[1])
			commentLine = true // This is the line we're replacing with real CommonJS
			logInfo.Printf("  Found exports-extension: %s", string(foundExtendExports[1]))
		}

		editedLine := line
		if commentLine {
			editedLine = append([]byte(`// REPLACED BY GOOG_TO_CJS::  `), line...)
		}
		editedLines = append(editedLines, editedLine)
	}

	editedLines = append(editedLines, []byte{})
	editedLines = append(editedLines, []byte{})
	editedLines = append(editedLines, []byte(`//=== CommonJS exports generated by goog_to_cjs`))

	for _, extendExport := range extendExports {
		for _, exportSymbol := range exportSymbols {
			// Look for symbols that are part of an exported namespace
			if !bytes.HasPrefix(exportSymbol, extendExport) {
				continue
			}
			// Get the actual name of the export
			exportName := exportSymbol[len(extendExport)+1:]
			buf := bytes.Buffer{}
			fmt.Fprintf(&buf, `export const %s = %s;`, exportName, exportSymbol)
			editedLines = append(editedLines, buf.Bytes())
			logInfo.Printf("  -> %s", buf.String())
		}
	}

	editedContent := bytes.Buffer{}
	for _, line := range editedLines {
		editedContent.Write(line)
		editedContent.WriteByte('\n')
	}
	if err := ioutil.WriteFile(file, editedContent.Bytes(), 0); err != nil {
		logError.Printf("failed to write %s: %v", file, err)
		return false
	}
	logInfo.Printf("✓ %s", file)
	return true
}

func main() {
	flag.Parse()
	targetFiles := flag.Args()
	successes := 0
	for _, f := range targetFiles {
		if patchGoogExportsToCjs(f) {
			successes++
		}
	}

	if successes < len(targetFiles) {
		logError.Printf("Finished with errors; (OK: %d/%d)", successes, len(targetFiles))
	} else {
		logInfo.Print("Done")
	}
}
